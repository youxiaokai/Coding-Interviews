# 16. 数值的整数次方

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

 

示例 1:

```
输入: 2.00000, 10
输出: 1024.00000
```


示例 2:

`输入: 2.10000, 3`
`输出: 9.26100`
示例 3:

`输入: 2.00000, -2`
`输出: 0.25000`
`解释: 2-2 = 1/22 = 1/4 = 0.25`


说明:

`-100.0 < x < 100.0`
`n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。`



**解法一  递归:**

这道题让我们求x的n次方，如果我们只是简单的用个for循环让x乘以自己n次的话，未免也把LeetCode上的题想的太简单了，一句话形容图样图森破啊。OJ因超时无法通过，所以我们需要优化我们的算法，使其在更有效的算出结果来。

我们可以用递归来折半计算，每次把n缩小一半，这样n最终会缩小到0，任何数的0次方都为1，这时候我们再往回乘，如果此时n是偶数，直接把上次递归得到的值算个平方返回即可，如果是奇数，则还需要乘上个x的值。还有一点需要引起我们的注意的是n有可能为负数，对于n是负数的情况，我们可以先用其绝对值计算出一个结果再取其倒数即可，之前是可以的，但是现在test case中加了个负2的31次方后，这就不行了，因为其绝对值超过了整型最大值，会有溢出错误，不过我们可以用另一种写法只用一个函数，在每次递归中处理n的正负，然后做相应的变换即可，代码如下：

```c++
class Solution {
public:
    double myPow(double x, int n) {
        if (n == 0) return 1;
        double half = myPow(x, n / 2);
        if (n % 2 == 0) return half * half;
        if (n > 0) return half * half * x;//n为正奇数时，需要多乘以x
        else return half * half / x;//n为负奇数时，需要多除以个x
    }
};
```

## 解法二：位运算

```C++
class Solution {
public:
    double myPow(double x, int n) {
        double res = 1.0;
        //i/=2就相当于右移一位
        for (int i = n; i != 0; i/=2) {
            if (i % 2 != 0) //看最后一位是否为1
                res *= x;
            x *= x;
        }
        return n < 0 ? 1 / res : res;
    }
};
```

