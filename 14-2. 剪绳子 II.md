# 14-2. 剪绳子 II

 

 题目描述

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m] 。请问 k[0]*k[1]*...*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

示例 2:

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

提示：

```
2 <= n <= 1000
```

 

##  DP的缺陷

这个题和剪绳子I一样的描述，就是数据范围变大了。剪绳子可以用动态规划或者贪心做，这道题对于使用DP难度就增大了一些，因为数据范围变得比较大时，long已经不足以去存储中间结果的状态，但是由于DP做法是枚举各种剪的情况然后取最大值，因此只能通过使用BigInteger的方法去做，这点评论区已经有人给出了解答。

那么这个题范围变大的本意是想让我们使用贪心算法能更好的求解(毕竟BigInteger使用起来麻烦，贪心没有数据溢出的问题，它是找当下的最优解，不需要比较，中间结果可以直接取模)。

## 贪心

我们首先考虑对于一段长n的绳子，我们可以切出的结果包含什么？

- 1会包含吗？ 不会，因为1 * (k - 1) < k, 只要把1和任何一个其他的片段组合在一起就有个更大的值
- 2可以
- 3可以
- 4可以吗？ 它拆成两个2的效果和本身一样，因此也不考虑
- 5以上可以吗？ 不可以，这些绳子必须拆，因为总有一种拆法比不拆更优，比如拆成 k / 2 和 k - k / 2

综上, 最后的结果只包含2和3(当然当总长度为2和3时单独处理), 那么很显然n >= 5时， 3*(n - 3) >= 2 * (n - 2) ，因此我们优先拆成3，最后剩余的拆成2。最后的结果一定是由若干个3和1或2个2组成.

## 代码

```C++
class Solution {
public:
    int cuttingRope(int n) {
        if(n<4) return n-1;
        long res=1; //此处必须是long，否则会溢出
        int mod=1000000007;
        while(n>4){
            n-=3;
            res*=3;
            res%=mod;
        }
        return (int)(res*n%mod);
    }
};
```

 

<iframe src="https://qiyukf.com/sdk/res/delegate.html?1593394312829" style="border: 0px; margin: 0px; padding: 0px; cursor: default !important; height: 0px; width: 0px;"></iframe>